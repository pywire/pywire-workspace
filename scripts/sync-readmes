#!/usr/bin/env python3
import os
import sys
import argparse
from pathlib import Path

TEMPLATES = {
    "SUPPORT": {
        "start_tag": "<!-- SUPPORT_MESSAGE_TEMPLATE_START -->",
        "end_tag": "<!-- SUPPORT_MESSAGE_TEMPLATE_END -->",
        "source": "org.github/SUPPORT_MESSAGE.md",
        "header": "## ‚ù§Ô∏è Support"
    },
    "INSTALL": {
        "start_tag": "<!-- INSTALL_MESSAGE_TEMPLATE_START -->",
        "end_tag": "<!-- INSTALL_MESSAGE_TEMPLATE_END -->",
        "source": "org.github/INSTALL_MESSAGE.md",
        "header": "## üöÄ Quick Start"
    }
}

def get_workspace_root():
    return Path(__file__).parent.parent.absolute()

def get_template_content(root, source_path):
    path = root / source_path
    if not path.exists():
        print(f"Error: Template source not found at {path}")
        sys.exit(1)
    return path.read_text().strip()

def sync_readme(readme_path, templates_data, check_only=False):
    content = readme_path.read_text()
    was_updated = False
    is_oot = False
    
    new_content = content
    
    for name, data in templates_data.items():
        start_tag = data["start_tag"]
        end_tag = data["end_tag"]
        template_content = data["content"]
        header = data["header"]
        
        if start_tag in new_content and end_tag in new_content:
            # Standard replacement
            start_idx = new_content.find(start_tag) + len(start_tag)
            end_idx = new_content.find(end_tag)
            
            new_inner = f"\n{template_content}\n"
            old_inner = new_content[start_idx:end_idx]
            
            if old_inner != new_inner:
                if check_only:
                    is_oot = True
                    continue
                
                new_content = new_content[:start_idx] + new_inner + new_content[end_idx:]
                was_updated = True
        
        elif header in new_content:
            # Found header but no tags, let's wrap it if not check_only
            if check_only:
                is_oot = True
                continue
                
            lines = new_content.splitlines()
            new_lines = []
            in_section = False
            captured_tags = False
            
            for line in lines:
                if line.startswith(header):
                    new_lines.append(start_tag)
                    new_lines.append(template_content)
                    new_lines.append(end_tag)
                    in_section = True
                    captured_tags = True
                    continue
                
                if in_section:
                    # Skip existing content until next header or end
                    if line.startswith("## ") or line.startswith("# "):
                        in_section = False
                        new_lines.append(line)
                    continue
                    
                new_lines.append(line)
                
            if captured_tags:
                new_content = "\n".join(new_lines) + "\n"
                was_updated = True
                
    if was_updated and not check_only:
        readme_path.write_text(new_content)
        
    return is_oot, was_updated

def main():
    parser = argparse.ArgumentParser(description="Sync support message and other templates across READMEs")
    parser.add_argument("--check", action="store_true", help="Only check for sync status")
    args = parser.parse_args()
    
    root = get_workspace_root()
    
    templates_data = {}
    for name, config in TEMPLATES.items():
        templates_data[name] = {
            **config,
            "content": get_template_content(root, config["source"])
        }
    
    out_of_sync = []
    updated = []
    
    # Exclude directories
    exclude_dirs = {".venv", "node_modules", ".git", ".mypy_cache", ".pytest_cache", "dist", "scratch"}
    
    for path in root.rglob("README.md"):
        # Check if any parent is in exclude_dirs
        if any(part in exclude_dirs for part in path.parts):
            continue
            
        is_oot, was_updated = sync_readme(path, templates_data, args.check)
        if is_oot:
            out_of_sync.append(path)
        if was_updated:
            updated.append(path)
            
    if args.check:
        if out_of_sync:
            print("The following files are out of sync:")
            for f in out_of_sync:
                print(f"  - {f.relative_to(root)}")
            sys.exit(1)
        else:
            print("All READMEs are in sync.")
    else:
        if updated:
            print("Updated the following files:")
            for f in updated:
                print(f"  - {f.relative_to(root)}")
        else:
            print("No files needed updating.")

if __name__ == "__main__":
    main()
